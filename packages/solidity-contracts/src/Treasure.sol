/**
 * Source Code first verified at https://etherscan.io on Wednesday, April 17, 2019
 (UTC) */

pragma solidity ^0.4.20;

/*


                                                                                                                                                            
                                                                                                                                                            
TTTTTTTTTTTTTTTTTTTTTTT                                                                                                                                     
T:::::::::::::::::::::T                                                                                                                                     
T:::::::::::::::::::::T                                                                                                                                     
T:::::TT:::::::TT:::::T                                                                                                                                     
TTTTTT  T:::::T  TTTTTTrrrrr   rrrrrrrrr       eeeeeeeeeeee      aaaaaaaaaaaaa       ssssssssss   uuuuuu    uuuuuu  rrrrr   rrrrrrrrr       eeeeeeeeeeee    
        T:::::T        r::::rrr:::::::::r    ee::::::::::::ee    a::::::::::::a    ss::::::::::s  u::::u    u::::u  r::::rrr:::::::::r    ee::::::::::::ee  
        T:::::T        r:::::::::::::::::r  e::::::eeeee:::::ee  aaaaaaaaa:::::a ss:::::::::::::s u::::u    u::::u  r:::::::::::::::::r  e::::::eeeee:::::ee
        T:::::T        rr::::::rrrrr::::::re::::::e     e:::::e           a::::a s::::::ssss:::::su::::u    u::::u  rr::::::rrrrr::::::re::::::e     e:::::e
        T:::::T         r:::::r     r:::::re:::::::eeeee::::::e    aaaaaaa:::::a  s:::::s  ssssss u::::u    u::::u   r:::::r     r:::::re:::::::eeeee::::::e
        T:::::T         r:::::r     rrrrrrre:::::::::::::::::e   aa::::::::::::a    s::::::s      u::::u    u::::u   r:::::r     rrrrrrre:::::::::::::::::e 
        T:::::T         r:::::r            e::::::eeeeeeeeeee   a::::aaaa::::::a       s::::::s   u::::u    u::::u   r:::::r            e::::::eeeeeeeeeee  
        T:::::T         r:::::r            e:::::::e           a::::a    a:::::a ssssss   s:::::s u:::::uuuu:::::u   r:::::r            e:::::::e           
      TT:::::::TT       r:::::r            e::::::::e          a::::a    a:::::a s:::::ssss::::::su:::::::::::::::uu r:::::r            e::::::::e          
      T:::::::::T       r:::::r             e::::::::eeeeeeee  a:::::aaaa::::::a s::::::::::::::s  u:::::::::::::::u r:::::r             e::::::::eeeeeeee  
      T:::::::::T       r:::::r              ee:::::::::::::e   a::::::::::aa:::a s:::::::::::ss    uu::::::::uu:::u r:::::r              ee:::::::::::::e  
      TTTTTTTTTTT       rrrrrrr                eeeeeeeeeeeeee    aaaaaaaaaa  aaaa  sssssssssss        uuuuuuuu  uuuu rrrrrrr                eeeeeeeeeeeeee  
                                                                                                                                                            
                                                                                                                                                            
                                                                                                                                                            
                                                                                                                                                            
                                                                                                                                                            
                                                                                                                                                            
                                                                                                                                                            

>>TreasureDapp worlds most unique and best decentralize application on Ethereum blockchain and powered by one of the most intelligent smart contract
that runs on a distributed computing system.

>>vitalik buterin gives idea of decentralize application.

=================INDIA is brain of worlds mathematic=========================

+++++++++++++++++Treasure ->where your Ethereum will grow<-+++++++++++++++++

\\\\\\\\\\\\\\\\\\\Code start with 0 zero and end with zero 0/////////////// 

>>>Aryabhatta was the first of the major mathematician-astronomers from the classical age of Indian mathematics and Indian astronomy<<<<<

====we believe in community growth=== 

>>"Gas" is the name for a special unit used in Ethereum. It measures how much "work" an action or set of actions takes to perform.

+++++we believe in equality++++++

>>crypro is made by Satoshi with is vision//////0xxxxxxx vision of decentralization of money and use crypto cryptography /////Bitcoin is the solution of every problem we face with fiat currency)))))

------------------ “We are products of our past, but we don't have to be prisoners of it--------------

}}}}}}we believe in transparency of Ethereum<<<<<<<<

==== algorithm is solution-------

++++smart contract with smart developers+++

/////nothing is out of A-Z & 0-9/////////

>>>.mlm change the main purpose of crypto////////where public money is in one hands]]]]]]]

>A man should never be ashamed to own he has been in the wrong, which is butsaying... that he is wiser today than he was yesterday. The only real mistake is the one from which we learn nothing. Many times what we perceive as an error or failure is actually a gift.

---but vision of TreasureDapp is true decentralizatio>>>>>where public money is 100% safe###
}}}}}}

TreasureDapp is a life time unstoppable and life time Ethereum earning programme/////

‘’==========TREASURE ethe’’’’blockchain…..used====for---dapp;;;;
सत्य -सत्यमेवेश्वरो लोके सत्ये धर्मः सदाश्रितः । सत्यमूलनि सर्वाणि सत्यान्नास्ति परं पदम् ॥
‘’’’’’’’’’’keep learning////


1 ether is 10^18 wei

1 ETH is represented by 10^18 of its natural unit (1 Ether = 1,000,000,000,000,000,000 wei).
[[[[[why Treasure is unique Ethereum blockchain decentralize application??????
**Your Tokens in Treasure is like a “TREE” just enjoy its fruits, as long as you will hold your tokens you will enjoy dividend in Ethereum and if you want to strong your “TREE” for more Ethereum just strong your tree by reinvest your dividends 
+ =no administrator and ambassador ,,>>>>
++=no reserve token for any developer,administrator,ambassador & founder////
++=no back door & public funds are safe in wallet deployed on Ethereum blockchain when no can withdraw these funds====
+++=it is not traditional dividend programme dependent only one enter/exit-----
++++=Treasure is first ever Dapp start crypto trading for dapp holders and share profit with them and it will be open source for all===
+++++=our vision is use of crypto as fiat and we are committed for this/////
++++++=anytime enter any time exit---- you are on safe platform===deal with Ethereum blockchain==
//////// Egyptian code cryptography////////
== we believe in smart contract & decentralization and that we are==
//////0xxxxxxxhashxxxxwe9xxxxxxxta12xxxxxxx0000000
=+we will grow even when people will not enter & exit in system and we are only people in universe of its kind/////
+++we understand power of 18 decimals and we used it==understand if you can>>>>>
_=on every community action you will earn===
^^sh///xxx00xxiva^^vai//shn]nav.’’’dav^^i
|||we made decentralized community|||
////////use treasure key for unlock the fortune////////////

=====================Leaders by example=======================

[[[[[[[made crypto for your generation with us]]]]]]] γ
^^^^^X00604xxxro^^ π hi79t//rsp^eth^trs^say//eth β β π yad….=bharat..**143^^^pak000xxxxshw1283^^ikaXOO
====Blockchain protection’’

=====================born for leadership=======================

^^eth^^18^^gwei^^0.00000000^^we^^the^^x000pexxople
//
#ethxooo369luc23ja01xxxxoooooooo14bojlxxxxxxxoooooooooooo

////no upline/no downline/no cross leg//no setting/no reserve token/open for all/eth/blockchain/smart contract/corporate/business/

[[[[audit report of every step by community]]]]funds are safu////////
^^^15%>>>>10%^^^^^^x000010%00^^^^5%eth/////20%>>>>>trs]]]]
!!!apl///made^^^^^smart_contart___blockchain___ethxxxxx000_safe_code
/////////code_protected-/////surxx0000\\\xxxxxxxxrat0000000000000000
^^^^9dav33kotxxxxxxxxxxxxxpitooooooedevjava///code-lock/unhack///system/


=====we are unstoppable===vision is clear====

*/

contract Treasure {
    
    /*=================================
    =            MODIFIERS            =
    =================================*/
    // only people with tokens
    modifier onlybelievers () {
        require(myTokens() > 0);
        _;
    }
    
    // only people with profits
    modifier onlyhodler() {
        require(myDividends(true) > 0);
        _;
    }
    
    // only people with sold token
    modifier onlySelingholder() {
        require(sellingWithdrawBalance_[msg.sender] > 0);
        _;
    }
    
    
    // administrators can:
    // -> change the name of the contract
    // -> change the name of the token
    // -> change the PoS difficulty 
    // they CANNOT:
    // -> take funds
    // -> disable withdrawals
    // -> kill the contract
    // -> change the price of tokens
    modifier onlyAdministrator(){
        address _customerAddress = msg.sender;
        require(administrators[keccak256(_customerAddress)]);
        _;
    }
    
    

    
    /*==============================
    =            EVENTS            =
    ==============================*/
    event onTokenPurchase(
        address indexed customerAddress,
        uint256 incomingEthereum,
        uint256 tokensMinted,
        address indexed referredBy
    );
    
    event onTokenSell(
        address indexed customerAddress,
        uint256 tokensBurned
    );
    
    event onReinvestment(
        address indexed customerAddress,
        uint256 ethereumReinvested,
        uint256 tokensMinted
    );
    
    event onWithdraw(
        address indexed customerAddress,
        uint256 ethereumWithdrawn
    );
    
    event onSellingWithdraw(
        
        address indexed customerAddress,
        uint256 ethereumWithdrawn
    
    );
    
    // ERC20
    event Transfer(
        address indexed from,
        address indexed to,
        uint256 tokens
    );
    
    
    /*=====================================
    =            CONFIGURABLES            =
    =====================================*/
    string public name = "Treasure";
    string public symbol = "TRS";
    uint8 constant public decimals = 18;
    uint8 constant internal dividendFee_ = 10;
    
    uint256 constant internal tokenPriceInitial_ = 0.000000001 ether;
    uint256 constant internal tokenPriceIncremental_ = 0.000000001 ether;

    
    
    // proof of stake (defaults at 1 token)
    uint256 public stakingRequirement = 1e18;
    
    
    
    // add community wallet here
    address internal constant CommunityWalletAddr = address(0x9E4F01bf4D6Aa5c583bcb84462e32e8a5cE6195F);
        
        //add trading wallet here
    address internal constant TradingWalletAddr = address(0xB0e9fF0C19b7147bFDeb81f0e1D3089efEc4fBCD);	 

    
    
   /*================================
    =            DATASETS            =
    ================================*/
    // amount of shares for each address (scaled number)
    mapping(address => uint256) internal tokenBalanceLedger_;
    mapping(address => uint256) internal referralBalance_;
    mapping(address => int256) internal payoutsTo_;
    mapping(address => uint256) internal sellingWithdrawBalance_;
    mapping(address => uint256) internal ambassadorAccumulatedQuota_;

    address[] private contractTokenHolderAddresses_;

    
    uint256 internal tokenSupply_ = 0;
    uint256 internal profitPerShare_;
    
    uint256 internal soldTokens_=0;
    uint256 internal contractAddresses_=0;
    uint256 internal tempIncomingEther=0;
    uint256 internal calculatedPercentage=0;
    
    
    uint256 internal tempProfitPerShare=0;
    uint256 internal tempIf=0;
    uint256 internal tempCalculatedDividends=0;
    uint256 internal tempReferall=0;
    uint256 internal tempSellingWithdraw=0;
    


    
    // administrator list (see above on what they can do)
    mapping(bytes32 => bool) public administrators;
    
    
    bool public onlyAmbassadors = false;
    


    /*=======================================
    =            PUBLIC FUNCTIONS            =
    =======================================*/
    /*
    * -- APPLICATION ENTRY POINTS --  
    */
    function Treasure()
        public
    {
        // add administrators here
           
        administrators[0x2d059f17f1d7fa6ef66aa46ab6061d07858fa96e9ed14401231e0c01510d7f1f] = true;
                     
						 
        
    }
    
     
    /**
     * Converts all incoming Ethereum to tokens for the caller, and passes down the referral address (if any)
     */
    function buy(address _referredBy)
        public
        payable
        returns(uint256)
    {
        purchaseTokens(msg.value, _referredBy);
    }
    
    
    function()
        payable
        public
    {
        purchaseTokens(msg.value, 0x0);
    }
    
    /**
     * Converts all of caller's dividends to tokens.
     */
    function reinvest()
        onlyhodler()
        public
    {
        address _customerAddress = msg.sender;

        // fetch dividends
        uint256 _dividends = myDividends(true); // retrieve ref. bonus later in the code
        
         //calculate  10 % for distribution 
        uint256  ten_percentForDistribution= SafeMath.percent(_dividends,10,100,18);

         //calculate  90 % to reinvest into tokens
        uint256  nighty_percentToReinvest= SafeMath.percent(_dividends,90,100,18);
        
        
        // dispatch a buy order with the calculatedPercentage 
        uint256 _tokens = purchaseTokens(nighty_percentToReinvest, 0x0);
        
        
        //Empty their  all dividends beacuse we are reinvesting them
         payoutsTo_[_customerAddress]=0;
         referralBalance_[_customerAddress]=0;
        
    
     
      //distribute to all as per holdings         
        profitPerShareAsPerHoldings(ten_percentForDistribution);
        
        // fire event
        onReinvestment(_customerAddress, _dividends, _tokens);
    }
    
    /**
     * Alias of sell() and withdraw().
     */
    function exit()
        public
    {
        // get token count for caller & sell them all
        address _customerAddress = msg.sender;
        uint256 _tokens = tokenBalanceLedger_[_customerAddress];
        if(_tokens > 0) sell(_tokens);
        
        
        withdraw();
    }

    /**
     * Withdraws all of the callers earnings.
     */
    function withdraw()
        onlyhodler()
        public
    {
        // setup data
        address _customerAddress = msg.sender;
        
        //calculate 20 % of all Dividends and transfer them to two communities
        //10% to community wallet
        //10% to trading wallet
        
        uint256 _dividends = myDividends(true); // get all dividends
        
        //calculate  10 % for trending wallet
        uint256  ten_percentForTradingWallet= SafeMath.percent(_dividends,10,100,18);

        //calculate 10 % for community wallet
         uint256 ten_percentForCommunityWallet= SafeMath.percent(_dividends,10,100,18);

        
        //Empty their  all dividends beacuse we are reinvesting them
         payoutsTo_[_customerAddress]=0;
         referralBalance_[_customerAddress]=0;
       
         // delivery service
        CommunityWalletAddr.transfer(ten_percentForCommunityWallet);
        
         // delivery service
        TradingWalletAddr.transfer(ten_percentForTradingWallet);
        
        //calculate 80% to tranfer it to customer address
         uint256 eighty_percentForCustomer= SafeMath.percent(_dividends,80,100,18);

       
        // delivery service
        _customerAddress.transfer(eighty_percentForCustomer);
        
        // fire event
        onWithdraw(_customerAddress, _dividends);
    }
    
     /**
     * Withdrawa all selling Withdraw of the callers earnings.
     */
    function sellingWithdraw()
        onlySelingholder()
        public
    {
        // setup data
        address _customerAddress = msg.sender;
        

        uint256 _sellingWithdraw = sellingWithdrawBalance_[_customerAddress] ; // get all balance
        

        //Empty  all sellingWithdraw beacuse we are giving them ethers
         sellingWithdrawBalance_[_customerAddress]=0;

     
        // delivery service
        _customerAddress.transfer(_sellingWithdraw);
        
        // fire event
        onSellingWithdraw(_customerAddress, _sellingWithdraw);
    }
    
    
    
     /**
     * Sell tokens.
     * Remember, there's a 10% fee here as well.
     */
    function sell(uint256 _amountOfTokens)
        onlybelievers ()
        public
    {
      
        address _customerAddress = msg.sender;
       
        //calculate 10 % of tokens and distribute them 
        require(_amountOfTokens <= tokenBalanceLedger_[_customerAddress]);
        uint256 _tokens = _amountOfTokens;
      
       uint256 _ethereum = tokensToEthereum_(_tokens);
        
          //calculate  10 % for distribution 
       uint256  ten_percentToDistributet= SafeMath.percent(_ethereum,10,100,18);

          //calculate  90 % for customer withdraw wallet
        uint256  nighty_percentToCustomer= SafeMath.percent(_ethereum,90,100,18);
        
        // burn the sold tokens
        tokenSupply_ = SafeMath.sub(tokenSupply_, _tokens);
        tokenBalanceLedger_[_customerAddress] = SafeMath.sub(tokenBalanceLedger_[_customerAddress], _tokens);
        
        //substract sold token from circulations of tokenSupply_
        soldTokens_=SafeMath.sub(soldTokens_,_tokens);
        
        // update sellingWithdrawBalance of customer 
       sellingWithdrawBalance_[_customerAddress] += nighty_percentToCustomer;       
        
       
        //distribute to all as per holdings         
       profitPerShareAsPerHoldings(ten_percentToDistributet);
      
      
        
        // fire event
        onTokenSell(_customerAddress, _tokens);
        
    }
    
    
    /**
     * Transfer tokens from the caller to a new holder.
     * Remember, there's a 5% fee here as well.
     */
    function transfer(address _toAddress, uint256 _amountOfTokens)
        onlybelievers ()
        public
        returns(bool)
    {
        // setup
        address _customerAddress = msg.sender;
        
        // make sure we have the requested tokens
     
        require(!onlyAmbassadors && _amountOfTokens <= tokenBalanceLedger_[_customerAddress]);
      
        //calculate 5 % of total tokens calculate Tokens Received
        uint256  five_percentOfTokens= SafeMath.percent(_amountOfTokens,5,100,18);
        
       
       //calculate 95 % of total tokens calculate Tokens Received
        uint256  nightyFive_percentOfTokens= SafeMath.percent(_amountOfTokens,95,100,18);
        
        
        // burn the fee tokens
        //convert ethereum to tokens
        tokenSupply_ = SafeMath.sub(tokenSupply_,five_percentOfTokens);
        
        //substract five percent from communiity of tokens
        soldTokens_=SafeMath.sub(soldTokens_, five_percentOfTokens);

        // exchange tokens
        tokenBalanceLedger_[_customerAddress] = SafeMath.sub(tokenBalanceLedger_[_customerAddress], _amountOfTokens);
        tokenBalanceLedger_[_toAddress] = SafeMath.add(tokenBalanceLedger_[_toAddress], nightyFive_percentOfTokens) ;
        

        //calculate value of all token to transfer to ethereum
        uint256 five_percentToDistribute = tokensToEthereum_(five_percentOfTokens);


        //distribute to all as per holdings         
        profitPerShareAsPerHoldings(five_percentToDistribute);

        // fire event
        Transfer(_customerAddress, _toAddress, nightyFive_percentOfTokens);
        
        
        return true;
       
    }
    
    /*----------  ADMINISTRATOR ONLY FUNCTIONS  ----------*/
    /**
     * administrator can manually disable the ambassador phase.
     */
    function disableInitialStage()
        onlyAdministrator()
        public
    {
        onlyAmbassadors = false;
    }
    
   
    function setAdministrator(bytes32 _identifier, bool _status)
        onlyAdministrator()
        public
    {
        administrators[_identifier] = _status;
    }
    
   
    function setStakingRequirement(uint256 _amountOfTokens)
        onlyAdministrator()
        public
    {
        stakingRequirement = _amountOfTokens;
    }
    
    
    function setName(string _name)
        onlyAdministrator()
        public
    {
        name = _name;
    }
    
   
    function setSymbol(string _symbol)
        onlyAdministrator()
        public
    {
        symbol = _symbol;
    }

    
    /*----------  HELPERS AND CALCULATORS  ----------*/
    /**
     * Method to view the current Ethereum stored in the contract
     * Example: totalEthereumBalance()
     */
    function totalEthereumBalance()
        public
        view
        returns(uint)
    {
        return this.balance;
    }
    
    /**
     * Retrieve the total token supply.
     */
    function totalSupply()
        public
        view
        returns(uint256)
    {
        return tokenSupply_;
    }
    
    /**
     * Retrieve the tokens owned by the caller.
     */
    function myTokens()
        public
        view
        returns(uint256)
    {
        address _customerAddress = msg.sender;
        return balanceOf(_customerAddress);
    }
    
    /**
     * Retrieve the sold tokens .
     */
    function soldTokens()
        public
        view
        returns(uint256)
    {

        return soldTokens_;
    }
    
    
    
    
    /**
     * Retrieve the dividends owned by the caller.
       */ 
    function myDividends(bool _includeReferralBonus) 
        public 
        view 
        returns(uint256)
    {
        address _customerAddress = msg.sender;
       return _includeReferralBonus ? dividendsOf(_customerAddress) + referralBalance_[_customerAddress] : dividendsOf(_customerAddress) ;

    }
    
    /**
     * Retrieve the token balance of any single address.
     */
    function balanceOf(address _customerAddress)
        view
        public
        returns(uint256)
    {
        return tokenBalanceLedger_[_customerAddress];
    }
    
    /**
     * Retrieve the selingWithdraw balance of address.
     */
    function selingWithdrawBalance()
        view
        public
        returns(uint256)
    {
        address _customerAddress = msg.sender;
         
        uint256 _sellingWithdraw = (uint256) (sellingWithdrawBalance_[_customerAddress]) ; // get all balance
        
        return  _sellingWithdraw;
    }
    
    /**
     * Retrieve the dividend balance of any single address.
     */
    function dividendsOf(address _customerAddress)
        view
        public
        returns(uint256)
    {
     
        return  (uint256) (payoutsTo_[_customerAddress]) ;

        
    }
    
    /**
     * Return the buy price of 1 individual token.
     */
    function sellPrice() 
        public 
        view 
        returns(uint256)
    {
       
        if(tokenSupply_ == 0){
            return tokenPriceInitial_ - tokenPriceIncremental_;
        } else {
            uint256 _ethereum = tokensToEthereum_(1e18);
            
            return _ethereum - SafeMath.percent(_ethereum,15,100,18);
        }
    }
    
    /**
     * Return the sell price of 1 individual token.
     */
    function buyPrice() 
        public 
        view 
        returns(uint256)
    {
        
        if(tokenSupply_ == 0){
            return tokenPriceInitial_ ;
        } else {
            uint256 _ethereum = tokensToEthereum_(1e18);
           
           
            return _ethereum;
        }
    }
    
   
    /**
     * Function to calculate actual value after Taxes
     */
    function calculateTokensReceived(uint256 _ethereumToSpend) 
        public 
        view 
        returns(uint256)
    {
         //calculate  15 % for distribution 
        uint256  fifteen_percentToDistribute= SafeMath.percent(_ethereumToSpend,15,100,18);

        uint256 _dividends = SafeMath.sub(_ethereumToSpend, fifteen_percentToDistribute);
        uint256 _amountOfTokens = ethereumToTokens_(_dividends);
        
        return _amountOfTokens;
    }
    
    
   
   
    function calculateEthereumReceived(uint256 _tokensToSell) 
        public 
        view 
        returns(uint256)
    {
        require(_tokensToSell <= tokenSupply_);
        
        uint256 _ethereum = tokensToEthereum_(_tokensToSell);
        
         //calculate  10 % for distribution 
        uint256  ten_percentToDistribute= SafeMath.percent(_ethereum,10,100,18);
        
        uint256 _dividends = SafeMath.sub(_ethereum, ten_percentToDistribute);

        return _dividends;

    }
    
    
    /*==========================================
    =            INTERNAL FUNCTIONS            =
    ==========================================*/
    
    
    function purchaseTokens(uint256 _incomingEthereum, address _referredBy)
        internal
        returns(uint256)
    {
        // data setup
        address _customerAddress = msg.sender;
        
        //check if address 
        tempIncomingEther=_incomingEthereum;
        
                bool isFound=false;
                
                for(uint k=0;k<contractTokenHolderAddresses_.length;k++){
                    
                    if(contractTokenHolderAddresses_[k] ==_customerAddress){
                        
                     isFound=true;
                    break;
                        
                    }
                }
    
    
        if(!isFound){
        
            //increment address to keep track of no of users in smartcontract
            contractAddresses_+=1;  
            
            contractTokenHolderAddresses_.push(_customerAddress);
                        
            }
    
     //calculate 85 percent
      calculatedPercentage= SafeMath.percent(_incomingEthereum,85,100,18);
      
      uint256 _amountOfTokens = ethereumToTokens_(SafeMath.percent(_incomingEthereum,85,100,18));    

        // we can't give people infinite ethereum
        if(tokenSupply_ > 0){
            
            // add tokens to the pool
            tokenSupply_ = SafeMath.add(tokenSupply_, _amountOfTokens);
 
        
        
        } else {
            // add tokens to the pool
            tokenSupply_ = _amountOfTokens;
        }
        
        // update circulating supply & the ledger address for the customer
        tokenBalanceLedger_[_customerAddress] = SafeMath.add(tokenBalanceLedger_[_customerAddress], _amountOfTokens);
        
        
        require(_amountOfTokens > 0 && (SafeMath.add(_amountOfTokens,tokenSupply_) > tokenSupply_));
        
        // is the user referred by a Treasure Key?
        if(
            // is this a referred purchase?
            _referredBy != 0x0000000000000000000000000000000000000000 &&

            // no cheating!
            _referredBy != _customerAddress &&
            
            // does the referrer have at least X whole tokens?
            // i.e is the referrer a godly chad masternode
            tokenBalanceLedger_[_referredBy] >= stakingRequirement
            
        ){
           
     // give 5 % to referral
     referralBalance_[_referredBy]+= SafeMath.percent(_incomingEthereum,5,100,18);
     
     tempReferall+=SafeMath.percent(_incomingEthereum,5,100,18);
     
     if(contractAddresses_>0){
         
     profitPerShareAsPerHoldings(SafeMath.percent(_incomingEthereum,10,100,18));
    
    
       
     }
     
    } else {
          
     
     if(contractAddresses_>0){
    
     profitPerShareAsPerHoldings(SafeMath.percent(_incomingEthereum,15,100,18));

 
        
     }
            
        }
        
      
    

        
        // fire event
        onTokenPurchase(_customerAddress, _incomingEthereum, _amountOfTokens, _referredBy);
        
        //calculate sold tokens here
        soldTokens_+=_amountOfTokens;
        
        return _amountOfTokens;
    }

   
     
   /**
     * Calculate Token price based on an amount of incoming ethereum
     * It's an algorithm, hopefully we gave you the whitepaper with it in scientific notation;
     * Some conversions occurred to prevent decimal errors or underflows / overflows in solidity code.
     */
     
    function ethereumToTokens_(uint256 _ethereum)
        internal
        view
        returns(uint256)
    {
        uint256 _tokenPriceInitial = tokenPriceInitial_ * 1e18;
        uint256 _tokensReceived = 
         (
            (
                // underflow attempts BTFO
                SafeMath.sub(
                    (sqrt
                        (
                            (_tokenPriceInitial**2)
                            +
                            (2*(tokenPriceIncremental_ * 1e18)*(_ethereum * 1e18))
                            +
                            (((tokenPriceIncremental_)**2)*(tokenSupply_**2))
                            +
                            (2*(tokenPriceIncremental_)*_tokenPriceInitial*tokenSupply_)
                        )
                    ), _tokenPriceInitial
                )
            )/(tokenPriceIncremental_)
        )-(tokenSupply_)
        ;
  
        return _tokensReceived;
    }
    
    /**
     * Calculate token sell value.
          */
     function tokensToEthereum_(uint256 _tokens)
        internal
        view
        returns(uint256)
    {

        uint256 tokens_ = (_tokens + 1e18);
        uint256 _tokenSupply = (tokenSupply_ + 1e18);
        uint256 _etherReceived =
        (
            // underflow attempts BTFO
            SafeMath.sub(
                (
                    (
                        (
                            tokenPriceInitial_ +(tokenPriceIncremental_ * (_tokenSupply/1e18))
                        )-tokenPriceIncremental_
                    )*(tokens_ - 1e18)
                ),(tokenPriceIncremental_*((tokens_**2-tokens_)/1e18))/2
            )
        /1e18);
        return _etherReceived;
    }
    
    //calculate profitPerShare as per holdings
    function profitPerShareAsPerHoldings(uint256 calculatedDividend)  internal {
    
       //calculate number of token 
       uint256 noOfTokens_;
        tempCalculatedDividends=calculatedDividend;

       for(uint i=0;i<contractTokenHolderAddresses_.length;i++){
         
         noOfTokens_+= tokenBalanceLedger_[contractTokenHolderAddresses_[i]];

        }
        
        //check if self token balance is zero then distribute to others as per holdings
        
    for(uint k=0;k<contractTokenHolderAddresses_.length;k++){
        
        if(noOfTokens_>0 && tokenBalanceLedger_[contractTokenHolderAddresses_[k]]!=0){
       

           profitPerShare_=SafeMath.percent(calculatedDividend,tokenBalanceLedger_[contractTokenHolderAddresses_[k]],noOfTokens_,18);
         
           tempProfitPerShare=profitPerShare_;

           payoutsTo_[contractTokenHolderAddresses_[k]] += (int256) (profitPerShare_) ;
           
           tempIf=1;

            
        }else if(noOfTokens_==0 && tokenBalanceLedger_[contractTokenHolderAddresses_[k]]==0){
            
            tempIf=2;
            tempProfitPerShare=profitPerShare_;

            payoutsTo_[contractTokenHolderAddresses_[k]] += (int256) (calculatedDividend) ;
        
            
        }
        
      }
        
        
    
        

    
    }
    
    //calculate square root
    function sqrt(uint x) internal pure returns (uint y) {
        uint z = (x + 1) / 2;
        y = x;
        while (z < y) {
            y = z;
            z = (x / z + z) / 2;
        }
    }
}

/**
 * @title SafeMath
 * @dev Math operations with safety checks that throw on error
 */
library SafeMath {
    
    function percent(uint value,uint numerator, uint denominator, uint precision) internal pure  returns(/*uint division,*/uint quotient) {

         // caution, check safe-to-multiply here
        uint _numerator  = numerator * 10 ** (precision+1);
        // with rounding of last digit
        uint _quotient =  ((_numerator / denominator) + 5) / 10;
        
       // uint division_=numerator/denominator;
        /* value*division_,*/
        return (value*_quotient/1000000000000000000);
  }


    
    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        if (a == 0) {
            return 0;
        }
        uint256 c = a * b;
        assert(c / a == b);
        return c;
    }

   
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        // assert(b > 0); // Solidity automatically throws when dividing by 0
        uint256 c = a / b;
        // assert(a == b * c + a % b); // There is no case in which this doesn't hold
        return c;
    }

    
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        assert(b <= a);
        return a - b;
    }

   
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        assert(c >= a);
        return c;
    }


    
}