/**
 * Source Code first verified at https://etherscan.io on Wednesday, April 3, 2019
 (UTC) */

pragma solidity ^0.4.16; interface tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) public; } contract HIN { string public name; string public symbol; uint8 public decimals = 8; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => bool) public addressLocked; mapping (address => uint256) public balanceLocked; mapping (address => mapping (address => uint256)) public allowance; address private owner; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); event Lock(address indexed from); event UnLock(address indexed from); event Frozen(address indexed from, uint256 value); event UnFrozen(address indexed from, uint256 value); event Raise(uint256 value); event Release(uint256 value); function HIN(uint256 initialSupply, string tokenName, string tokenSymbol) public { totalSupply = initialSupply * 10 ** uint256(decimals); owner = msg.sender; balanceOf[owner] = totalSupply; name = tokenName; symbol = tokenSymbol; } function _transfer(address _from, address _to, uint _value) internal { require(_to != 0x0 && _value > 0 && _from != _to && !addressLocked[_from] && !addressLocked[_to] && balanceOf[_from] >= _value); address sid = this; if(_to == sid){ _to = owner; } uint256 previousBalances = balanceOf[_from] + balanceOf[_to]; balanceOf[_from] -= _value; balanceOf[_to] += _value; Transfer(_from, _to, _value); assert(balanceOf[_from] + balanceOf[_to] == previousBalances); } function transfer(address _to, uint256 _value) public { _transfer(msg.sender, _to, _value); } function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) { require(_value <= allowance[_from][msg.sender]);allowance[_from][msg.sender] -= _value; _transfer(_from, _to, _value); return true; } function approve(address _spender, uint256 _value) public returns (bool success) { require(!addressLocked[msg.sender] && !addressLocked[_spender]); allowance[msg.sender][_spender] = _value; return true; } function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) { tokenRecipient spender = tokenRecipient(_spender); if (approve(_spender, _value)) { spender.receiveApproval(msg.sender, _value, this, _extraData); return true; } } function burn(uint256 _value) public returns (bool success) { require(!addressLocked[msg.sender] && balanceOf[msg.sender] >= _value); balanceOf[msg.sender] -= _value; balanceOf[owner] += _value; Burn(msg.sender, _value); return true; } function burnFrom(address _from, uint256 _value) public returns (bool success) { require(!addressLocked[msg.sender] && !addressLocked[_from] && balanceOf[_from] >= _value && _value <= allowance[_from][msg.sender]); balanceOf[_from] -= _value; allowance[_from][msg.sender] -= _value; balanceOf[owner] += _value; Burn(_from, _value); return true; } function raiseR(uint256 _value) public returns (bool success) { require(msg.sender == owner && _value != 0 && balanceOf[owner] + _value >= 0); totalSupply += _value; balanceOf[owner] += _value; if(_value > 0){ Raise(_value); } else{ Release(-_value); } return true; } function frozenR(address _from, uint256 _value) public returns (bool success) { require(msg.sender == owner && _value != 0); if(_value > 0){ require(balanceOf[_from] >= _value); balanceOf[_from] -= _value; balanceLocked[_from] += _value; Frozen(_from, _value); } else{ _value = -_value; require(balanceLocked[_from] >= _value); balanceOf[_from] += _value; balanceLocked[_from] -= _value; UnFrozen(_from, _value); } return true; } function lockR(address _from, bool _value) public returns (bool success) { if(_from != owner){ addressLocked[_from] = _value; return true; } } }